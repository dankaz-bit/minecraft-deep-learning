# Imports:
import os.path
import argparse
import shutil

import tensorflow as tf
from quiver_engine import server
from keras.models import Sequential
from keras.layers import Lambda

from minecraft_deep_learning.environment import build_environment
from minecraft_deep_learning.model import build_agent
from minecraft_deep_learning.processor import MinecraftProcessor
from minecraft_deep_learning.callbacks import use_callbacks
from minecraft_deep_learning.display import (
    close_display,
    get_pressed_action,
)
from minecraft_deep_learning.constants import (
    NUM_STEPS,
    LOG_INTERVAL,
    TESTING_EPISODES,
    WEIGHTS_DIR,
    ESTIMATED_TIME,
    RANDOM_START_STEPS,
    USE_ACTIONS,
    IMAGES_DIR,
    INPUT_SIZE,
    CHANNELS,
    WINDOW_SIZE,
    BASE_DIR,
)

# Argument parser:
final_weights_file = os.path.join(WEIGHTS_DIR, "weights_final.h5f")

arguments = argparse.ArgumentParser()
arguments.add_argument(
    "--mode",
    choices=["train", "test", "play", "quiver"],
    default="train",
)
arguments.add_argument(
    "--weights",
    type=str,
    default=final_weights_file,
)

# Argument handling:
def run(args):
    """Process the given parsed arguments."""
    env = None
    try:
        if args.mode == "play":
            env = build_environment()
            proc = MinecraftProcessor(always_show_rewards=True)
            proc.use_display()
            proc._action = env.action_space.sample()
            def proc.handle_events():
                action_name = None
                while action_name is None:
                    action_name = get_pressed_action()
                proc._action = env.action_names[0].index(action_name)
            done = True
            while True:
                if done:
                    env.reset()
                obs, reward, done, info = (
                    proc._action
                    |> env.step
                    |*> proc.process_step
                )

        elif args.mode == "train":
            agent, env = build_agent(), build_environment()
            print("Estimated training time: {}".format(ESTIMATED_TIME))
            agent.fit(
                env,
                callbacks=use_callbacks,
                nb_steps=NUM_STEPS,
                nb_max_start_steps=RANDOM_START_STEPS,
                log_interval=LOG_INTERVAL,
            )
            agent.save_weights(final_weights_file, overwrite=True)

        elif args.mode == "test":
            agent, env = build_agent(), build_environment()
            agent.load_weights(args.weights)
            agent.test(
                env,
                nb_episodes=TESTING_EPISODES,
                nb_max_start_steps=RANDOM_START_STEPS,
                visualize=False,
            )

        elif args.mode == "quiver":
            agent = build_agent()
            agent.load_weights(args.weights)
            quiver_model = Sequential([
                Lambda(tensor ->
                    tensor/255.0
                    |> tensor -> [tensor]*WINDOW_SIZE
                    |> tf.stack
                    |> tf.transpose$(perm=[1, 0, 4, 2, 3])
                    |> tf.reshape$(shape=(-1, CHANNELS * WINDOW_SIZE) + INPUT_SIZE),
                    input_shape=INPUT_SIZE + (CHANNELS,)
                ),
            ] + [
                (def layer ->
                    layer.inbound_nodes = [];
                    layer)(layer)
                for layer in agent.model.layers
            ])
            temp_dir = os.path.join(BASE_DIR, "tmp")
            p_dir = os.path.join(BASE_DIR, "-p")
            try:
                server.launch(
                    quiver_model,
                    USE_ACTIONS,
                    temp_folder=temp_dir,
                    input_folder=IMAGES_DIR,
                )
            finally:
                print("Shutting down...")
                if os.path.exists(temp_dir):
                    shutil.rmtree(temp_dir)
                if os.path.exists(p_dir):
                    shutil.rmtree(p_dir)

        else:
            raise ValueError("unknown --mode {!r}".format(args.mode))
    finally:
        if env is not None:
            env.close()

def main(raw_args=None):
    """Parse arguments and pass them to run."""
    if raw_args is None:
        args = arguments.parse_args()
    else:
        args = arguments.parse_args(raw_args)
    try:
        run(args)
    finally:
        close_display()
